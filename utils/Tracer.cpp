#include "pin.H"
#include <iostream>
#include <fstream>
#include <iomanip>

/* ===================================================================== */
/* Global Variables */
/* ===================================================================== */

std::ofstream TraceFile;

/* ===================================================================== */
/* Commandline Switches */
/* ===================================================================== */

KNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool",
    "o", "trace-full-info.asm", "specify trace file name");

/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */

INT32 Usage()
{
    cerr <<
        "This tool produces a compressed (dynamic) instruction trace.\n"
        "The trace is still in textual form but repeated sequences\n"
        "of the same code are abbreviated with a number which dramatically\n"
        "reduces the output size and the overhead of the tool.\n"
        "\n";

    cerr << KNOB_BASE::StringKnobSummary();

    cerr << endl;

    return -1;
}

/*
TraceFile << "# 0x" << ip << " " << r << " [" << addr << "]" << " size = " << size << " value = " << hex << val <<  endl;
*/

VOID printInst(VOID * ip, string *disass)
{
	TraceFile << "0x" << ip << " " << *disass << endl;
}

static VOID EmitMem(VOID * ea, INT32 size)
{
    
    switch(size)
    {
      case 0:
        TraceFile << setw(1);
        break;
        
      case 1:
        TraceFile << static_cast<UINT32>(*static_cast<UINT8*>(ea));
        break;
        
      case 2:
        TraceFile << *static_cast<UINT16*>(ea);
        break;
        
      case 4:
        TraceFile << *static_cast<UINT32*>(ea);
        break;
        
      case 8:
        TraceFile << *static_cast<UINT64*>(ea);
        break;
        
      default:
        TraceFile.unsetf(ios::showbase);
        TraceFile << setw(1) << "0x";
        for (INT32 i = 0; i < size; i++)
        {
            TraceFile << static_cast<UINT32>(static_cast<UINT8*>(ea)[i]);
        }
        TraceFile.setf(ios::showbase);
        break;
    }
}

static VOID RecordMem(VOID * ip, CHAR r, VOID * addr, INT32 size, BOOL isPrefetch)
{
	TraceFile << "# " << ip << ": " << r << " " << setw(2+2*sizeof(ADDRINT)) << addr << ", size = "
              << dec << setw(2) << size << ", value = "
              << hex << setw(2+2*sizeof(ADDRINT));
    if (!isPrefetch)
        EmitMem(addr, size);
    TraceFile << endl;
}

static VOID * WriteAddr;
static INT32 WriteSize;

static VOID RecordWriteAddrSize(VOID * addr, INT32 size)
{
    WriteAddr = addr;
    WriteSize = size;
}


static VOID RecordMemWrite(VOID * ip)
{
    RecordMem(ip, 'W', WriteAddr, WriteSize, false);
}

VOID Instruction(INS ins, VOID *v)
{
	ADDRINT ceip = INS_Address(ins);
	string* disass = new string(INS_Disassemble(ins));

	if(ceip >= 0x0401000 && ceip <= 0x617000)
	{

		if (INS_IsMemoryRead(ins))
		{
			INS_InsertPredicatedCall(
				ins, IPOINT_BEFORE, (AFUNPTR)RecordMem,
				IARG_INST_PTR,
				IARG_UINT32, 'R',
				IARG_MEMORYREAD_EA,
				IARG_MEMORYREAD_SIZE,
				IARG_BOOL, INS_IsPrefetch(ins),
				IARG_END);
		}

		if (INS_HasMemoryRead2(ins))
		{
			INS_InsertPredicatedCall(
				ins, IPOINT_BEFORE, (AFUNPTR)RecordMem,
				IARG_INST_PTR,
				IARG_UINT32, 'R',
				IARG_MEMORYREAD2_EA,
				IARG_MEMORYREAD_SIZE,
				IARG_BOOL, INS_IsPrefetch(ins),
				IARG_END);
		}

		// instruments stores using a predicated call, i.e.
		// the call happens iff the store will be actually executed
		if (INS_IsMemoryWrite(ins))
		{
			INS_InsertPredicatedCall(
				ins, IPOINT_BEFORE, (AFUNPTR)RecordWriteAddrSize,
				IARG_MEMORYWRITE_EA,
				IARG_MEMORYWRITE_SIZE,
				IARG_END);

			if (INS_HasFallThrough(ins))
			{
				INS_InsertCall(
					ins, IPOINT_AFTER, (AFUNPTR)RecordMemWrite,
					IARG_INST_PTR,
					IARG_END);
			}
			if (INS_IsBranchOrCall(ins))
			{
				INS_InsertCall(
					ins, IPOINT_TAKEN_BRANCH, (AFUNPTR)RecordMemWrite,
					IARG_INST_PTR,
					IARG_END);
			}

		}

		INS_InsertCall(
			ins, IPOINT_BEFORE, (AFUNPTR)printInst,
			IARG_INST_PTR,
			IARG_PTR, disass,
			IARG_END);
	}
}


VOID Fini(INT32 code, VOID *v)
{
    TraceFile.close();
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */

int  main(int argc, char *argv[])
{
    string trace_header = string("#\n"
                                 "# Compressed Instruction Trace Generated By Pin\n"
                                 "#\n");
    
    
    if( PIN_Init(argc,argv) )
    {
        return Usage();
    }
    

    TraceFile.open(KnobOutputFile.Value().c_str());
    TraceFile.write(trace_header.c_str(),trace_header.size());
    
        
    INS_AddInstrumentFunction(Instruction, 0);
    PIN_AddFiniFunction(Fini, 0);

    // Never returns

    PIN_StartProgram();
    
    return 0;
}

/* ===================================================================== */
/* eof */
/* ===================================================================== */
